#pragma version 10

PuyaContracts.MIMC.contract.MIMC.approval_program:
    // src/PuyaContracts/MIMC/contract.py:19
    // class MIMC(ARC4Contract):
    txna ApplicationArgs 0
    method "create()void"
    method "initialize()void"
    method "multimimc7()void"
    method "verify_hash(byte[],byte[])void"
    uncover 4
    match main_create_route@1 main_initialize_route@2 main_multimimc7_route@3 main_verify_hash_route@4
    b main_switch_case_default@5

main_create_route@1:
    // src/PuyaContracts/MIMC/contract.py:20
    // @arc4.abimethod(create="require")
    txn OnCompletion
    int NoOp
    ==
    assert // OnCompletion is NoOp
    txn ApplicationID
    !
    assert // is creating
    callsub create
    int 1
    return

main_initialize_route@2:
    // src/PuyaContracts/MIMC/contract.py:24
    // @arc4.abimethod()
    txn OnCompletion
    int NoOp
    ==
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub initialize
    int 1
    return

main_multimimc7_route@3:
    // src/PuyaContracts/MIMC/contract.py:45
    // @arc4.abimethod()
    txn OnCompletion
    int NoOp
    ==
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub multimimc7
    int 1
    return

main_verify_hash_route@4:
    // src/PuyaContracts/MIMC/contract.py:89
    // @arc4.abimethod()
    txn OnCompletion
    int NoOp
    ==
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/PuyaContracts/MIMC/contract.py:19
    // class MIMC(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // src/PuyaContracts/MIMC/contract.py:89
    // @arc4.abimethod()
    callsub verify_hash
    int 1
    return

main_switch_case_default@5:
    // src/PuyaContracts/MIMC/contract.py:19
    // class MIMC(ARC4Contract):
    err // reject transaction


// PuyaContracts.MIMC.contract.MIMC.create() -> void:
create:
    // src/PuyaContracts/MIMC/contract.py:20-21
    // @arc4.abimethod(create="require")
    // def create(self) -> None:
    proto 0 0
    retsub


// PuyaContracts.MIMC.contract.MIMC.initialize() -> void:
initialize:
    // src/PuyaContracts/MIMC/contract.py:24-25
    // @arc4.abimethod()
    // def initialize(self) -> None:
    proto 0 0
    // src/PuyaContracts/MIMC/contract.py:26-27
    // # Read data to hash from notes
    // gtxn_notes: Bytes = aggregate_gtxn_notes()
    callsub aggregate_gtxn_notes
    // src/PuyaContracts/MIMC/contract.py:30
    // mimc_payload.mimc_hash_preimage.bytes
    dup
    int 82
    extract_uint16
    cover 1
    dup
    len
    cover 1
    uncover 2
    uncover 2
    substring3
    // src/PuyaContracts/MIMC/contract.py:29-31
    // mimc_hash_preimage: Bytes = decode_dynamic_bytes(
    //     mimc_payload.mimc_hash_preimage.bytes
    // )
    callsub decode_dynamic_bytes
    // src/PuyaContracts/MIMC/contract.py:32
    // sha256_id: Bytes = sha256(mimc_hash_preimage)
    dup
    sha256
    // src/PuyaContracts/MIMC/contract.py:34-35
    // # Set the r value
    // r_box = Box(BigUInt, key=concat(b"r", sha256_id))
    byte 0x72
    dig 1
    concat
    // src/PuyaContracts/MIMC/contract.py:36
    // r_box.value = BigUInt(0)
    dup
    box_del
    pop
    byte 0x
    box_put
    // src/PuyaContracts/MIMC/contract.py:38-39
    // # Set the counters
    // num_chunks_box = Box(UInt64, key=concat(b"num_chunks", sha256_id))
    byte 0x6e756d5f6368756e6b73
    dig 1
    concat
    // src/PuyaContracts/MIMC/contract.py:40
    // num_chunks_box.value = mimc_hash_preimage.length // 32
    uncover 2
    len
    int 32
    /
    itob
    box_put
    // src/PuyaContracts/MIMC/contract.py:42
    // num_completed_box = Box(UInt64, key=concat(b"num_completed", sha256_id))
    byte 0x6e756d5f636f6d706c65746564
    uncover 1
    concat
    // src/PuyaContracts/MIMC/contract.py:43
    // num_completed_box.value = UInt64(0)
    int 0
    itob
    box_put
    retsub


// PuyaContracts.common.aggregate_gtxn_notes() -> bytes:
aggregate_gtxn_notes:
    // src/PuyaContracts/common.py:27-28
    // @subroutine
    // def aggregate_gtxn_notes() -> Bytes:
    proto 0 1
    // src/PuyaContracts/common.py:29
    // data: Bytes = Bytes(b"")
    byte 0x
    // src/PuyaContracts/common.py:30
    // group_size: UInt64 = Global.group_size
    global GroupSize
    // src/PuyaContracts/common.py:31
    // for i in urange(group_size):
    int 1
    assert // Step cannot be zero
    int 0

aggregate_gtxn_notes_for_header@1:
    // src/PuyaContracts/common.py:31
    // for i in urange(group_size):
    frame_dig 2
    frame_dig 1
    <
    bz aggregate_gtxn_notes_after_for@5
    frame_dig 2
    // src/PuyaContracts/common.py:32
    // note: Bytes = gtxn.Transaction(i).note
    gtxns Note
    // src/PuyaContracts/common.py:33
    // data += note
    frame_dig 0
    uncover 1
    concat
    frame_bury 0
    // src/PuyaContracts/common.py:31
    // for i in urange(group_size):
    frame_dig 2
    int 1
    +
    frame_bury 2
    b aggregate_gtxn_notes_for_header@1

aggregate_gtxn_notes_after_for@5:
    // src/PuyaContracts/common.py:34
    // return data
    frame_dig 0
    frame_bury 0
    retsub


// PuyaContracts.common.decode_dynamic_bytes(value: bytes) -> bytes:
decode_dynamic_bytes:
    // src/PuyaContracts/common.py:23-24
    // @subroutine
    // def decode_dynamic_bytes(value: Bytes) -> Bytes:
    proto 1 1
    // src/PuyaContracts/common.py:25
    // return substring(value, 2, value.length)
    frame_dig -1
    len
    frame_dig -1
    int 2
    uncover 2
    substring3
    retsub


// PuyaContracts.MIMC.contract.MIMC.multimimc7() -> void:
multimimc7:
    // src/PuyaContracts/MIMC/contract.py:45-46
    // @arc4.abimethod()
    // def multimimc7(self) -> None:
    proto 0 0
    // src/PuyaContracts/MIMC/contract.py:47
    // gtxn_notes: Bytes = aggregate_gtxn_notes()
    callsub aggregate_gtxn_notes
    // src/PuyaContracts/MIMC/contract.py:49
    // start_idx: UInt64 = btoi(mimc_payload.compute_start_idx.bytes)
    dup
    int 64
    int 8
    extract3 // on error: Index access is out of bounds
    btoi
    cover 1
    // src/PuyaContracts/MIMC/contract.py:50
    // end_idx: UInt64 = btoi(mimc_payload.compute_end_idx.bytes)
    dup
    int 72
    int 8
    extract3 // on error: Index access is out of bounds
    btoi
    cover 1
    // src/PuyaContracts/MIMC/contract.py:52
    // mimc_hash: Bytes = mimc_payload.mimc_hash.bytes
    dup
    int 0
    int 32
    extract3 // on error: Index access is out of bounds
    cover 3
    // src/PuyaContracts/MIMC/contract.py:53-55
    // previous_r_value: BigUInt = BigUInt.from_bytes(
    //     mimc_payload.previous_r_value.bytes
    // )
    dup
    // src/PuyaContracts/MIMC/contract.py:54
    // mimc_payload.previous_r_value.bytes
    int 32
    int 32
    extract3 // on error: Index access is out of bounds
    // src/PuyaContracts/MIMC/contract.py:53-55
    // previous_r_value: BigUInt = BigUInt.from_bytes(
    //     mimc_payload.previous_r_value.bytes
    // )
    cover 1
    // src/PuyaContracts/MIMC/contract.py:57
    // mimc_payload.mimc_hash_preimage.bytes
    dup
    int 82
    extract_uint16
    cover 1
    dup
    len
    cover 1
    uncover 2
    uncover 2
    substring3
    // src/PuyaContracts/MIMC/contract.py:56-58
    // mimc_hash_preimage: Bytes = decode_dynamic_bytes(
    //     mimc_payload.mimc_hash_preimage.bytes
    // )
    callsub decode_dynamic_bytes
    // src/PuyaContracts/MIMC/contract.py:59
    // sha256_id: Bytes = sha256(mimc_hash_preimage)
    sha256
    dup
    cover 5
    // src/PuyaContracts/MIMC/contract.py:61
    // num_chunks_box = Box(UInt64, key=concat(b"num_chunks", sha256_id))
    byte 0x6e756d5f6368756e6b73
    dig 1
    concat
    cover 2
    // src/PuyaContracts/MIMC/contract.py:63-64
    // # r value integrity
    // r_box = Box(BigUInt, key=concat(b"r", sha256_id))
    byte 0x72
    dig 1
    concat
    dup
    cover 7
    // src/PuyaContracts/MIMC/contract.py:67
    // previous_r_value == r_box.value
    dup
    box_get
    assert // check Box exists
    uncover 3
    uncover 1
    b==
    // src/PuyaContracts/MIMC/contract.py:66-68
    // assert (
    //     previous_r_value == r_box.value
    // ), "Previous r value must match that previously computed last round"
    assert // Previous r value must match that previously computed last round
    // src/PuyaContracts/MIMC/contract.py:70-71
    // # start index integrity
    // num_completed_box = Box(UInt64, key=concat(b"num_completed", sha256_id))
    byte 0x6e756d5f636f6d706c65746564
    uncover 2
    concat
    // src/PuyaContracts/MIMC/contract.py:72
    // assert num_completed_box.value == start_idx, "Start index must be contiguous"
    dup
    box_get
    cover 1
    btoi
    uncover 1
    assert // check Box exists
    dig 5
    ==
    assert // Start index must be contiguous
    // src/PuyaContracts/MIMC/contract.py:74-75
    // # end indx integrity
    // assert start_idx < end_idx, "Start idx must be less than end idx"
    uncover 4
    dig 4
    <
    assert // Start idx must be less than end idx
    // src/PuyaContracts/MIMC/contract.py:76
    // assert end_idx <= num_chunks_box.value
    dig 2
    box_get
    cover 1
    btoi
    uncover 1
    assert // check Box exists
    dig 4
    uncover 1
    <=
    assert
    // src/PuyaContracts/MIMC/contract.py:78-79
    // # Update r value
    // r_box.value = BigUInt.from_bytes(mimc_hash)
    uncover 4
    dig 2
    box_del
    pop
    uncover 2
    uncover 1
    box_put
    // src/PuyaContracts/MIMC/contract.py:81-82
    // # Update number of hashed chunks
    // num_completed_box.value = end_idx
    uncover 2
    itob
    dig 1
    uncover 1
    box_put
    // src/PuyaContracts/MIMC/contract.py:84-85
    // # Record hash result once all chunks hashed
    // if num_completed_box.value >= num_chunks_box.value:
    box_get
    cover 1
    btoi
    cover 1
    assert // check Box exists
    uncover 1
    box_get
    cover 1
    btoi
    uncover 1
    assert // check Box exists
    >=
    bz multimimc7_after_if_else@2
    // src/PuyaContracts/MIMC/contract.py:86
    // result_box = Box(Bytes, key=concat(b"result", sha256_id))
    byte 0x726573756c74
    frame_dig 0
    concat
    // src/PuyaContracts/MIMC/contract.py:87
    // result_box.value = r_box.value.bytes
    frame_dig 1
    box_get
    assert // check Box exists
    dig 1
    box_del
    pop
    box_put

multimimc7_after_if_else@2:
    retsub


// PuyaContracts.MIMC.contract.MIMC.verify_hash(data_sha256: bytes, data_mimc: bytes) -> void:
verify_hash:
    // src/PuyaContracts/MIMC/contract.py:89-90
    // @arc4.abimethod()
    // def verify_hash(self, data_sha256: Bytes, data_mimc: Bytes) -> None:
    proto 2 0
    // src/PuyaContracts/MIMC/contract.py:91-92
    // # Assert the computation is complete
    // num_chunks_box = Box(UInt64, key=concat(b"num_chunks", data_sha256))
    byte 0x6e756d5f6368756e6b73
    frame_dig -2
    concat
    // src/PuyaContracts/MIMC/contract.py:93
    // num_completed_box = Box(UInt64, key=concat(b"num_completed", data_sha256))
    byte 0x6e756d5f636f6d706c65746564
    frame_dig -2
    concat
    // src/PuyaContracts/MIMC/contract.py:95
    // num_completed_box.value >= num_chunks_box.value
    box_get
    cover 1
    btoi
    cover 1
    assert // check Box exists
    uncover 1
    box_get
    cover 1
    btoi
    uncover 1
    assert // check Box exists
    >=
    // src/PuyaContracts/MIMC/contract.py:94-96
    // assert (
    //     num_completed_box.value >= num_chunks_box.value
    // ), "Number of compute iterations must at least exceed number of 32 byte chunks"
    assert // Number of compute iterations must at least exceed number of 32 byte chunks
    // src/PuyaContracts/MIMC/contract.py:97-98
    // # Asserts the hashes are sha256/mimc of the data
    // result_box = Box(Bytes, key=concat(b"result", data_sha256))
    byte 0x726573756c74
    frame_dig -2
    concat
    // src/PuyaContracts/MIMC/contract.py:99
    // assert result_box.value == data_mimc, "MIMC hash matches computed value"
    box_get
    assert // check Box exists
    frame_dig -1
    ==
    assert // MIMC hash matches computed value
    retsub
